import json
import logging
import os
import sys

from mpt import settings
from mpt import functions
from mpt import logger

from colorama import Fore, Back, Style


def singleton(cls):
    instances = {}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper

@singleton
class Config:

    def __init__(self):
        self.config_path = os.path.join(settings.HOME_FOLDER, settings.CONFIG)
        self.log = logger.getLogger()
        self.config_dict = self.load()

    def print(self):
        """
    Print configuration file
    """
        functions.run_as(user='user')

        self.log.info(f"Configuration file: {self.config_path}")
        config_json = json.dumps(self.config_dict, indent=4)
        print(config_json)

    def update(self, config_name, config_value):
        """
    Update configuration file to the following structure
    @see __write_config for more details

    :param config_name:
    :param config_value:
    :return:
    """
        if not os.path.isfile(self.config_path):
            self.log.error(f"Configuration file {self.config_path} missing")
            sys.exit(3)

        if config_name in self.config_dict.keys():

            self.config_dict.update({config_name: config_value})
            self.__write_config(self.config_dict)
            self.config_dict = self.load()
            self.log.info(f"Updated config: {config_name}")
        else:
            self.log.error(
                f"Configuration error: Key \"{config_name}\" not found. Skip adding value \"{config_value}\"")

    def __write_config(self, config_dict):
        """
    # private method

      # configuration file
      {
        "pentest-dir": "/path/to/pentest-YYYY-MM-DD",
        "app": "app/file.apk",
        "install-dir": "tools/MOBILE/"
        "package-name": "com.example.app",
        "proxy": {
            "host": "127.0.0.1",
            "port": "8080"
        }
      }

    Write python dict object as json config file
    :param config_dict:
    :return:
    """

        # set default values
        for conf in config_dict.keys():
            if conf not in settings.CONFIG_ITEMS:
                self.log.error(f"Unknown config key \"{conf}\". Configuration writing not possible")
                sys.exit(1)

        # write config file
        with open(self.config_path, 'w') as json_file:
            self.log.debug(f"Writing config dict to file: {self.config_dict}")
            # pretty json
            json.dump(config_dict, json_file, indent=4, sort_keys=True)
            json_file.close()

        if os.path.isfile(self.config_path):
            self.log.debug(f"Configuration file {self.config_path} updated")

    def load(self):
        """
    Loads configuration json file from path and return a dict

    :return:
    """
        config_path = os.path.join(settings.HOME_FOLDER, settings.CONFIG)


        self.config_dict = {}

        # load existing config file
        if os.path.isfile(config_path):
            self.log.debug(f"Loading config file: {config_path}")
            with open(config_path, 'r') as json_file:
                self.config_dict = json.load(json_file)
                json_file.close()

                # load pretty json
                # config_json = json.dumps(config_dict, indent=4)
                # print(config_json)
                return self.config_dict

        # create a new config file
        else:

            # set default values
            self.log.info(f'Configuration file {config_path} missing. Init a new config ...')

            # set default installation folder
            self.set_tool_folder()

            # set default properties
            for conf in settings.CONFIG_ITEMS:
                if conf not in self.config_dict.keys():
                    self.log.debug(f"config key \"{conf}\" not found. Set default value.")
                    self.config_dict.update({conf: ""})

            self.config_dict.update({'proxy': {'host': settings.PROXY_SERVER, 'port': settings.PROXY_PORT}})

            self.__write_config(self.config_dict)
            self.log.debug(f'Configuration file {config_path} created')


    def load_config(self, setting_name):

        functions.run_as(user='user')

        # check settings_name as key
        for conf in self.config_dict.keys():
            if conf not in settings.CONFIG_ITEMS:
                self.log.error(f"Unknown config key \"{conf}\". Loading key failed")
                sys.exit(1)

        return self.config_dict[setting_name]

    def set_tool_folder(self):

        # define MOBILE_FOLDER variable and create this folder, if not exists

        tool_dir = settings.DEFAULT_MOBILE_FOLDER
        self.log.info("Please set a default installation folder for tools")

        use_tool_dir = functions.yes_no(
            'Would you use this directory {} [Yes|No]? '.format(Style.BRIGHT + Fore.CYAN + tool_dir + Style.RESET_ALL))

        if not use_tool_dir:
            tool_dir = self.get_custom_tool_dir(tool_dir)

        if os.path.isdir(tool_dir):
            self.config_dict.update({'install-dir': tool_dir})
        else:
            self.log.warn(f"Folder \"{tool_dir}\" does not exists and will be created")
            code = functions.run_command(f"mkdir -p {tool_dir}", returncode=True)
            if code == 0:
                self.config_dict.update({'install-dir': tool_dir})
            else:
                self.log.error(f"Folder {tool_dir} could not be created")
                self.set_tool_folder()




    def get_custom_tool_dir(self, tool_dir):
        r = 0
        while True:
            tmp_tool_dir = input("Please put absolute path to installation folder for tools: ")

            use_tool_dir = functions.yes_no(
                'Would you use this directory {} [Yes|No]? '.format(
                    Style.BRIGHT + Fore.CYAN + tmp_tool_dir + Style.RESET_ALL))
            if use_tool_dir:
                if not tmp_tool_dir.startswith("/"):
                    self.log.warn("that is not absolute path, select another folder")
                    return self.get_custom_tool_dir(tmp_tool_dir)
                else:
                    return tmp_tool_dir
            else:
                return self.get_custom_tool_dir(tmp_tool_dir)
