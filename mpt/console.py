#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import os
import shutil
import subprocess
import sys

from colorama import Fore, Back, Style
from simple_term_menu import TerminalMenu

from mpt import functions

__version__ = '0.7.7'

from mpt import settings, logger
from mpt.config import Config



def create_pentest_folder_with_absolute_path():
    pentest_path = input("Please put absolute path to pentest project folder: ")

    if not pentest_path.startswith("/"):
        log.warn("that is not absolute path, select another folder. Setup canceled")
        sys.exit()

    use_tool_dir = functions.yes_no(
        'Would you like to use this directory {} [Yes|No]? '.format(
            Style.BRIGHT + Fore.CYAN + pentest_path + Style.RESET_ALL))
    if use_tool_dir:
        os.makedirs(os.path.join(pentest_path, settings.APP_FOLDER))
        os.makedirs(os.path.join(pentest_path, settings.BACKUP_FOLDER))
        return pentest_path
    else:
        log.warn("Setup canceled")
        sys.exit()

def setup_pentest(apk):
    functions.run_as(user='user')


    apk_file = ''.join(apk)
    if os.path.isfile(apk_file):
        if not (apk_file.endswith('.apk') or apk_file.endswith('.APK')):
            log.error('File does not have required extension: apk')
            sys.exit()

        aapt_bin = settings.ANDROID_TOOLS['aapt']['bin']

        # get package name
        # aapt dump badging <path-to-apk> | grep package:\ name
        out = functions.run_command('{}  dump badging {} | grep package:\ name'.format(aapt_bin, apk_file),return_output=True)
        # extract package name from output message
        package = ''.join(out).split('package: name=\'')[1].split('\' versionCode')[0]

        pentest_path = os.path.join(os.getcwd(), settings.PENTEST_FOLDER)

        # remove pentest folder, if exists
        if os.path.isdir(pentest_path):
            log.warn("Pentest folder {} already exists.".format(pentest_path))

            options = ["Delete folder content", "select another path", "Skip setup"]
            terminal_menu = TerminalMenu(options, title="Please select an option:")
            menu_entry_index = terminal_menu.show()

            if menu_entry_index == 0:
                shutil.rmtree(pentest_path)
                log.debug(f"Folder {pentest_path} recreated")
                os.makedirs(os.path.join(pentest_path, settings.APP_FOLDER))
                os.makedirs(os.path.join(pentest_path, settings.BACKUP_FOLDER))
            if (menu_entry_index == 1):
                pentest_path = create_pentest_folder_with_absolute_path()
            if (menu_entry_index == 2):
                log.warn("Folder {} already exists. Skip setup".format(settings.PENTEST_FOLDER))
                sys.exit()

        else:

            # create a new pentest project
            option1 = "use folder \"{}\"".format(pentest_path)
            options = [option1, "select another path", "skip setup"]
            terminal_menu = TerminalMenu(options, title="Start new pentest project ...")
            menu_entry_index = terminal_menu.show()

            if (menu_entry_index == 0):
                os.makedirs(os.path.join(pentest_path, settings.APP_FOLDER))
                os.makedirs(os.path.join(pentest_path, settings.BACKUP_FOLDER))
            if (menu_entry_index == 1):
                pentest_path = create_pentest_folder_with_absolute_path()
            if (menu_entry_index == 2): # Skip
                log.warn("Skip setup".format(settings.PENTEST_FOLDER))
                sys.exit()


        if not os.path.isdir(pentest_path):
            log.error("Error: folder {} could not be created".format(pentest_path))
            sys.exit()
        # TODO print message before overwriting the folder
        log.info("Folder for security assessment {} created".format(Fore.CYAN + settings.PENTEST_FOLDER + Style.RESET_ALL))

        app_name = os.path.join(settings.APP_FOLDER, os.path.basename(apk_file))
        shutil.copy(apk_file, os.path.join(pentest_path, app_name))

        # update configuration
        conf = Config()
        conf.update('pentest-dir', pentest_path)
        conf.update('app', app_name)
        conf.update('package-name', package)

        install_app = functions.yes_no(
            'Would you like to install application {} on device [Yes|No]? '.format(
                Style.BRIGHT + Fore.CYAN + package + Style.RESET_ALL))

        # app install
        if (install_app):
            functions.check_adb_device()
            log.info('Installing apk file: {}'.format(apk_file))
            functions.run_command('adb install "{}"'.format(apk_file))

    else:
        log.error('File {} does not exist'.format(apk_file))




def list_packages(show_all_pkgs):
    functions.run_as(user='user')
    functions.check_adb_device()
    print_all = False

    if show_all_pkgs == 'all':
        print_all = True

    if print_all:
        log.info('Print all installed packages')
    else:
        log.info('Only user apps are listed. ' + Style.BRIGHT + Fore.WHITE + 'Use option \'-l all\' to display all packages.' + Style.RESET_ALL  )

    packages = functions.run_command(command="""adb shell 'pm list packages -f' | cut -d ":" -f 2""",
                                     print_output=False)

    for p in sorted(packages):

        package = p.rstrip("\n\r").split(".apk=")
        package[0] = package[0] + ".apk"

        # print user packages in bold, do not show default google applications
        if package[0].find('/data/app/') >= 0 \
                and not (package[1].startswith('com.google') or package[1].startswith('com.android')):
            package[0] = Style.BRIGHT + package[0] + Style.RESET_ALL

        # print all apps including system
        if print_all:
            sys.stdout.write(Fore.CYAN + package[1] + Style.RESET_ALL + "\n" + "[APP]: " + package[0] + "\n")

        # print only user apps
        else:
            # do not show default google applications
            if package[0].find('/data/app/') >= 0 \
                    and not (package[1].startswith('com.google') or package[1].startswith('com.android')):
                sys.stdout.write(Fore.CYAN + package[1] + Style.RESET_ALL + "\n" + "[APP]: " + package[0] + "\n")

        # run_command(command="""adb shell 'pm list packages -f' | sed -e 's/.*=//' | sort""", print_output=False)


def run_pidcat(package_name):
    functions.run_as(user='user')
    functions.check_adb_device()

    if not package_name:
        conf = Config()
        package_name = conf.load_config('package-name')

    functions.app_installed(package_name)

    tool_name = 'pidcat'
    width_left = 30
    pidcat_bin = settings.ANDROID_TOOLS[tool_name]['bin']

    functions.run_command(command='python3 -u  {} -w {} {}'.format(pidcat_bin, width_left, package_name), print_output=True,
                          universal_newlines=True)

def run_pidcat_ex(package_name):
    functions.run_as(user='user')
    functions.check_adb_device()

    if not package_name:
        conf = Config()
        package_name = conf.load_config('package-name')

    functions.app_installed(package_name)

    tool_name = 'pidcat-ex'
    width_left = 30
    pidcat_bin = settings.ANDROID_TOOLS[tool_name]['bin']

    functions.run_command(command='python3 -u {0} -w {1} {2} --hl '
                        '\'{2}\\yellow|/data/data/\\blue|/data/user/\\blue|/data/app/\\blue'
                        '|.so\\cyan|activity\\green|Exception\\bg_red\''
                          .format(pidcat_bin, width_left, package_name),
                          print_output=True,
                          universal_newlines=True)

def backup_app(package_name):
    functions.run_as(user='user')
    functions.check_adb_device()
    abe_bin = settings.ANDROID_TOOLS['abe']['bin']
    app_tar = "backup.tar"
    adb_backup = "backup.ab"

    if not package_name:
        conf = Config()
        package_name = conf.load_config('package-name')

    functions.app_installed(package_name)
    log.info('Backing up application {}'.format(package_name))

    print("Enter your comment for backup (optional):")
    for comment in sys.stdin:
        comment = comment.strip("\n")
        break
    log.debug("comment: {} , len = {}".format(comment, len(comment)))

    # find next folder index
    for index in range(1, 100):
        if len(comment) > 0:
            dirname = 'backup{}_{}_{}'.format(index,package_name, comment)
        else:
            dirname = 'backup{}_{}'.format(index, package_name)
        conf = Config()
        pentest_dir = conf.load_config('pentest-dir')
        backup_dir = os.path.join(pentest_dir, settings.BACKUP_FOLDER, dirname)

        # list directories
        dirs = ''.join(os.listdir(os.path.join(pentest_dir, settings.BACKUP_FOLDER)))

        # check if backup<index> folder does not exist
        if dirs.find( "backup" + str(index) ) < 0:
            # backup_dir =  backup<last_index>
            log.info('Backup folder: {}'.format(backup_dir))
            break

    #TODO check whether backup is allowed: <application android:allowBackup="true"

    #TODO automated clicking on button backup my data
    # adb shell input text 0000       # enter password 0000
    # adb shell 'dumpsys window displays | grep cur='
    # init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1794x1731

    print("Please enter password 0000 on the device")
    backup_dir_tmp = backup_dir + '_tmp'
    os.makedirs(backup_dir_tmp)

    backup_file = os.path.join(backup_dir_tmp, adb_backup)
    app_tar = os.path.join(backup_dir_tmp, app_tar)
    functions.run_command('adb backup -app -f "{0}" {1}'.format(backup_file, package_name))

    log.debug("tar file: " + app_tar)
    log.info('Unpacking backup file')
    functions.run_command(command='java -jar {} unpack "{}" "{}" 0000 &> /dev/null'.format(abe_bin, backup_file, app_tar),
                          print_output=True)

    file_list = functions.run_command(command='tar -tvf "{}"'.format(app_tar), return_output=True)

    if not file_list:
        log.error("Backup file {} is empty. Maybe the application is compiled with android:allowBackup=\"false\""
                  .format(os.path.basename(app_tar)))
        shutil.rmtree(backup_dir_tmp)
        sys.exit()

    functions.run_command(command='tar xf "{}" -C "{}"'.format(app_tar, backup_dir_tmp), print_output=True)


    # move files to backup folder
    shutil.copytree( os.path.join(backup_dir_tmp + '/apps/' + package_name  + '/'), backup_dir)

    files = {'db': 'databases',
             'f': 'files',
             'sp': 'shared_prefs',
             'ef': 'external_storage_files',
             'r': 'root'}
    # rename files
    for key in files.keys():
        if os.path.isdir(os.path.join(backup_dir, key)):
            shutil.move(os.path.join(backup_dir, key), os.path.join(backup_dir, files[key]))

    shutil.rmtree(backup_dir_tmp)


def generate_jar_file():
    """
    :return converted jar from APP_FOLDER:
    """
    conf = Config()
    app_dir = os.path.join(conf.load_config('pentest-dir'), settings.APP_FOLDER)
    apk_file = conf.load_config('app')
    jar_file = ""
    for file in os.listdir(app_dir):
        if file.endswith('.jar'):
            jar_file = file
            log.debug(f"jar file available: {jar_file}")

    if not jar_file:
        # run command cd pentest-folder; d2j-dex2jar  test.apk
        code = functions.run_command('cd {}; {} "{}"'.format(app_dir, settings.ANDROID_TOOLS['dex2jar']['bin'],
                                                             os.path.basename(apk_file)),
                                     returncode=True, return_output=False)
        if code != 0:
            log.error('Converting dex to class files using dex2jar failed')
            exit(1)

        for file in os.listdir(app_dir):
            if file.endswith('.jar'):
                jar_file = file

        log.debug(f"jar file generated: {jar_file}")

    #if os.path.exists(osapp_dir)

    return jar_file

def run_decompiler(decompiler):
    functions.run_as(user='user')

    if (len(decompiler) == 0):
        decompiler = settings.DECOMPILER

    if decompiler in ['jd-gui', 'jadx', 'luyten']:
        log.info("Decompiler: " + decompiler)

        conf = Config()
        if decompiler == 'jd-gui':
            app_dir = os.path.join(conf.load_config('pentest-dir'), settings.APP_FOLDER)
            jar_file = generate_jar_file()
            decompiler_bin = os.path.join(conf.load_config('install-dir'), settings.ANDROID_TOOLS['jd-gui']['bin'])
            functions.run_command('cd {}; java -jar {} "{}"'.format(app_dir, decompiler_bin, jar_file), print_output=True)

        if decompiler == 'jadx':
            apk_file = os.path.join(conf.load_config('pentest-dir'), conf.load_config('app'))
            decompiler_bin = os.path.join(conf.load_config('install-dir'), settings.ANDROID_TOOLS['jadx']['bin'])
            functions.run_command('{} "{}"'.format(decompiler_bin, apk_file), print_output=True)

        if decompiler == 'luyten':
            app_dir = os.path.join(conf.load_config('pentest-dir'), settings.APP_FOLDER)
            jar_file = generate_jar_file()
            decompiler_bin = os.path.join(conf.load_config('install-dir'), settings.ANDROID_TOOLS['luyten']['bin'])
            functions.run_command('cd {}; java -jar {} "{}"'.format(app_dir, decompiler_bin, jar_file), print_output=True)
    else:
        log.warn("Decompiler {} is unknown. Available options: jadx|jd-gui|luyten".format(decompiler))
        sys.exit(1)





# prints usage of run_tool
def print_run_tool_usage():

    print("list of available tools:")
    for package in settings.ANDROID_TOOLS:

        if 'info' in settings.ANDROID_TOOLS[package].keys():
            placeholder = ""
            if len(package) < 5:
                placeholder = "       "
            print(" * {}{} \t [ {} ]".format(package, placeholder, settings.ANDROID_TOOLS[package]['info']))
        else:
            print(" * {}".format(package))

    print("\n use: mpt -t <toolname> <args> to run command")
    print("  if you pass the argument to file location please use absolute path !!!")


def run_tool(tool_with_args):
    """
    Accepts only two parameters tool + <arg>
    <args> multiple parameters are accepted
    :param tool_with_args:
    :return:
    """
    functions.run_as(user='user')

    if not tool_with_args:
        print_run_tool_usage()
        sys.exit()

    tool = tool_with_args[0]
    tool_args = ""
    if len(tool_with_args) > 1:
        tool_args = ' '.join(tool_with_args[1:len(tool_with_args)])

    if tool == 'list' or tool not in settings.ANDROID_TOOLS.keys():
        print_run_tool_usage()
        sys.exit()

    if tool in settings.ANDROID_TOOLS.keys():

        # check if dir variable is set
        if 'dir' not in settings.ANDROID_TOOLS[tool].keys():
            log.error("variable \'dir\' for tool {} is not set".format(tool))
            sys.exit()

        log.info("Running tool {} ...".format(Style.BRIGHT + tool + Style.RESET_ALL))
        conf = Config()
        tool_dir = os.path.join(conf.load_config('install-dir'), settings.ANDROID_TOOLS[tool]['dir'])
        if os.path.exists(tool_dir):
            
            if 'bin_info' in settings.ANDROID_TOOLS[tool]:
                log.info(settings.ANDROID_TOOLS[tool]['bin_info'])

            command = settings.ANDROID_TOOLS[tool]['bin']
            if command.endswith(".jar"):
                command = 'java -jar ' + command

            # run tool + <args> (all parameters will be processed)
            if tool_args:
                command = command + " " + tool_args

            if tool == 'objection':
                functions.run_command_in_terminal(command)
            # default case
            else:
                log.debug("Command: {}".format(Style.BRIGHT + command + Style.RESET_ALL))
                functions.run_command(command=command, return_output=True, shell=True, print_output=True)
        else:
            log.error("{} not found".format(settings.ANDROID_TOOLS[tool]['bin']))
    else:
        log.error(f"{tool} tool not found")
        print_run_tool_usage()


def run_inspeckage():
    functions.run_as(user='user')
    functions.check_adb_device()
    functions.app_installed('mobi.acpm.inspeckage')

    url =  'http://127.0.0.1:8008'
    functions.run_command(command='adb forward tcp:8008 tcp:8008', print_output=True)

    # check if drozer server is running
    returncode = functions.run_command(command='curl -I -s {}'.format(url), returncode=True)

    if returncode != 0:
        log.error('Could not connect to the Inspeckage server. Please start inspeckage app on your mobile phone and chouse target application')
        sys.exit(returncode)

    functions.run_command(command=' {} {}'.format(settings.BROWSER, url), returncode=True)



def toggle_proxy(proxy):
    functions.run_as(user='user')
    functions.check_adb_device()

    if proxy:
        proxy_host = proxy.split(':')[0]
        proxy_port = proxy.split(':')[1]

    else:
        conf = Config()
        proxy_host = conf.load_config('proxy')['host']
        proxy_port = conf.load_config('proxy')['port']

    proxy_check = functions.run_command(command='adb shell settings get global http_proxy')[0].replace('\n', '')

    if proxy_check.find(proxy_port) < 0:

        id = functions.get_shell_user_id()

        # adb shell running as root (virtual device)
        if id.find('uid=0(root)') >= 0:
            log.info("Running on virtual device")
            command = "adb shell settings put global http_proxy {}:{}".format(proxy_host, proxy_port)
        else:
            log.info("Running on physical device")
            # adb shell running as user (physical device)
            command = 'adb shell su -c "settings put global http_proxy 192.168.188.125:8080"'.format(proxy_host, proxy_port)

        functions.run_command(command='adb shell settings put global http_proxy {}:{}'
                              .format(proxy_host, proxy_port), return_output=True)

        proxy_current = functions.run_command(command='adb shell settings get global http_proxy', return_output=True)[0].replace(
            '\n', '')
        log.success('Proxy enabled: {}'.format(proxy_current))

    else:
        functions.run_command(command='adb shell settings put global http_proxy :0')
        log.success("Proxy disabled")
        proxy_current = functions.run_command(command='adb shell settings get global http_proxy', return_output=True)[0].replace(
            '\n', '')


def run_frida_script(package_name, frida_script):
    """
    :param package_name: Android package name
    :param frida_script: frida scirpt file location
    :return: None
    """

    functions.run_as(user='user')
    functions.check_adb_device()

    log.debug('pwd: ' + settings.MPT_PATH)
    frida_script = os.path.join(settings.MPT_PATH, frida_script)

    if not package_name:
        conf = Config()
        package_name = conf.load_config('package-name')

    functions.app_installed(package_name)
    functions.check_frida_is_running()

    if os.path.isfile(frida_script):

        log.info("Frida script {} loaded\n".format(os.path.basename(frida_script)))
        functions.run_interactive_command(command='frida -R -f {} -l {}'.format(package_name, frida_script))
    else:
        log.error('File not found: {}'.format(frida_script))


def disable_ssl_pinning(package_name):

    log.info("Disabling SSL Pinning: " + Fore.CYAN + package_name + Style.RESET_ALL)
    frida_script = "scripts/frida/frida-sslpinning-disable.js"
    frida_script = os.path.join(settings.MPT_PATH, frida_script)

    run_frida_script(package_name, frida_script)


def disable_root_detection(package_name):

    log.info("Disabling Root Detection: " + Fore.CYAN + package_name + Style.RESET_ALL)
    frida_script = "scripts/frida/frida-bypass-root-detection.js"
    frida_script = os.path.join(settings.MPT_PATH, frida_script)

    run_frida_script(package_name, frida_script)



def lower_list(l):
    return [x.lower() for x in l]


def run_fridump():

    functions.run_as(user='user')
    functions.check_adb_device()

    conf = Config()
    package_name = conf.load_config('package-name')
    functions.app_installed(package_name)
    app_file_path = os.path.join(conf.load_config('pentest-dir'), conf.load_config('app'))
    fridump_bin = settings.ANDROID_TOOLS['fridump']['bin']
    aapt_bin = settings.ANDROID_TOOLS['aapt']['bin']

    # get app label
    # aapt  dump badging apk/doctolib_2021-07.apk | grep application-label:
    sp = subprocess.Popen('{} dump badging {} | grep application-label:'.format(aapt_bin, app_file_path), shell=True, stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE, universal_newlines=True)
    out, err = sp.communicate()

    # extract package name from output message
    app_label = out.split('application-label:\'')[1].split('\'')[0]
    log.info('Dumping application memory ({}) ...'.format(app_label))

    # python ~/fridump/fridump.py -U -s Chrome
    dump_output_dir = os.path.join(conf.load_config('pentest-dir'), 'dump')
    # create dump folder
    if not os.path.isdir(dump_output_dir):
        os.makedirs(dump_output_dir)
    functions.run_command(command='python {} -U -s \'{}\' -o {}'.format(fridump_bin, app_label, dump_output_dir),
                          print_output=True,
                          universal_newlines=True)


"""
def start_appmon(package_name):
    run_as(user='user')
    check_adb_device()
    pip_packages = ['frida', 'flask', 'termcolor', 'dataset', 'htmlentities']
    setting_package = "package-name"
    appmon_folder = "appmon"

    installed_packages = run_command(command='python -m pip freeze')
    installed_packages = [x.replace('\n', '').split('==')[0] for x in installed_packages]

    not_installed_pkgs = set(lower_list(pip_packages)) - set(lower_list(installed_packages))

    if not_installed_pkgs:
        log.error("Please install required packages: {}".format(not_installed_pkgs))
        sys.exit()

    if not package_name:
        check_setting(setting_name=setting_package)
        settings = read_settings()
        package_name = settings['package-name']

    log.info('[+] Inspected app: {}'.format(package_name))

    appmon_path = os.path.join(settings.MOBILE_FOLDER, appmon_folder)
    appmon_executable = os.path.join(appmon_path, 'appmon.py')

    functions.check_frida_is_running()
    log.info("[+] Starting appmon sniffer")
    functions.run_command(command='python2 {} -p android -s {} -a {}'
                          .format(appmon_executable, os.path.join(appmon_path, 'scripts/Android'), package_name),
                          print_output=True)
"""



def print_banner():
    banner = """{}                        __    _ __                         __            __     __              ____   _ __ 
       ____ ___   ___  / /_  (_) /__     ____  ___  ____  / /____  _____/ /_   / /_____  ____  / / /__(_) /_
      / __ \`__ \/__ \/ __ \/ / / _ \   / __ \/ _ \/ __ \/ __/ _ \/ ___/ __/  / __/ __ \/ __ \/ / //_/ / __/
     / / / / / / /_/ / /_/ / / /  __/  / /_/ /  __/ / / / /_/  __(__  ) /_/  / /_/ /_/ / /_/ / / ,< / / /_  
    /_/ /_/ /_/\____/_.___/_/_/\___/  / .___/\___/_/ /_/\__/\___/____/\__/   \__/\____/\____/_/_/|_/_/\__/  
                                     /_/                 
    {}
    Written by @coreb1t (Alexander Subbotin) @bytesnipers
    Version: {}
    """.format(Fore.GREEN,Style.RESET_ALL,__version__)
    print(banner)


def cli():

    parser = argparse.ArgumentParser(description=print_banner())

    global log
    log = logger.getLogger()
    conf = Config()

    parser.add_argument('--setup', metavar='[APK]', nargs=1, type=str,
                        help='setup pentest environment')
    parser.add_argument('--config', help='show current pentest config', action='store_true')
    parser.add_argument('-i', '--install', metavar='tools|apps', nargs='?', type=str, const='', help='Install required packages')
    parser.add_argument('-a', '--adb-run', help='Start adb server', action='store_true')
    parser.add_argument('-l', '--list-packages', metavar='all', nargs='?', type=str, const='',
                        help='Show all installed packages (use option \'all\' to display system apps)')
    parser.add_argument('-p', '--pidcat',metavar='package-name', nargs='?', type=str, const='', help='Show colored logcat for a specific'
                                                                              ' application (<package name> optional)')
    parser.add_argument('-D', '--fridump', help='Dump application memory', action='store_true')
    parser.add_argument('-b', '--backup',metavar='package-name', nargs='?', type=str, const='', help='Backup an android application'
                                               ' \n (<package name> optional)')
    parser.add_argument('-d', '--decompile', metavar='decompiler', nargs='?', type=str, const='', help='Start java decompiler for course code analysis (<decompiler> optional): jadx(default), jd-gui, luyten')
    parser.add_argument('-f', '--frida', help='Run frida server on the device', action='store_true')
    # parser.add_argument('-e', '--inspeckage', help='Open Inspeckage web interface', action='store_true')
    # nargs='+' accept multiple parameters like -t janus path/to/apk
    parser.add_argument('-t', '--tool', metavar='tool', nargs='+',
                        help='Run selected tool with <arguments> (use option \'list\' to display all tools)')
    #parser.add_argument('-t', '--tool', metavar='toolname <args>', default='list', nargs='+', help='Run selected tool (use option \'list\' to display all tools)')
    #parser.add_argument('-d', '--drozer', help='Run drozer application', action='store_true')
    parser.add_argument('-w', '--wifi-proxy', metavar='host:port', nargs='?', type=str, const='', help='Enable/Disable WiFi Proxy (optional <host:port>)"')
    parser.add_argument('-s', '--ssl-pinning',metavar='package-name', nargs='?', type=str, const='',
                        help='Disable SSL Pinning (<package name> optional)')
    parser.add_argument('-r', '--root-detection', metavar='package-name', nargs='?', type=str, const='',
                        help='Disable Root Detection (<package name> optional)')
    #parser.add_argument('-n', '--start-appmon', nargs='?', type=str, const='',
    #                    help='Start Appmon - Sniffer (<package name> optional)',
    #                    metavar='package name')

    if (len(sys.argv) == 1):
        parser.print_usage()
        sys.exit()

    args = parser.parse_args()

    if args.config:
        conf.print()
    if args.setup or type(args.setup) is str :
        setup_pentest(apk=args.setup)  # done
    if args.install or type(args.install) is str :
        functions.install_packages(install=args.install)
    if args.adb_run:
        functions.run_adb()
    if args.list_packages or type(args.list_packages) is str :
        list_packages(show_all_pkgs=args.list_packages)
    if args.pidcat or type(args.pidcat) is str:
        # run_pidcat(package_name=args.pidcat)        # replaced pidcat mit pidcat-extended
        run_pidcat_ex(package_name=args.pidcat)
    if args.backup or type(args.backup) is str:
        backup_app(package_name=args.backup)
    if args.decompile or type(args.decompile) is str:
        run_decompiler(decompiler=args.decompile)
    if args.frida:
        functions.run_frida()
    if args.tool:
        run_tool(tool_with_args=args.tool)
    #if args.inspeckage:
    #    run_inspeckage()
    #if args.drozer:
    #    run_drozer()
    if args.wifi_proxy or type(args.wifi_proxy) is str:
        toggle_proxy(proxy=args.wifi_proxy)
    if args.ssl_pinning or type(args.ssl_pinning) is str:
        disable_ssl_pinning(package_name=args.ssl_pinning)  # done
    if args.root_detection or type(args.root_detection) is str:
        disable_root_detection(package_name=args.root_detection)  # done
    if args.fridump:
        run_fridump()
    #if args.start_appmon or type(args.start_appmon) is str:
    #    start_appmon(package_name=args.start_appmon)
