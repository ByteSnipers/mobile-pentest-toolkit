import os
from . import logger
import subprocess
import sys
import shutil
from git import Repo
from . import settings
from mpt import mpt
from tabulate import tabulate
from colorama import Fore, Back, Style
from urllib.parse import urlparse

log = logger.getLogger()



def check_command(command_name):
    if not shutil.which(command_name):
        log.error("Couldn't find {}".format(command_name))
        sys.exit(1)


def print_device_table():
    devices = run_command(command='adb devices -l | grep -w device')

    devs = []
    for device in ''.join(devices).split('\n'):
        info = device.split()
        if len(info) > 0:
            for i in info:
                if i.find('product:') >= 0:
                    product = i.split(':')[1]
                if i.find('model:') >= 0:
                    model = i.split(':')[1]

            devs.append([info[0], product, model])
    log.info('ADB attached devices:')
    print(tabulate(devs, headers=['ID', 'Product', 'Model']))


def check_adb_device():
    check_command(command_name='adb')
    devices = run_command(command='adb devices -l | grep -w device')

    if not devices:
        log.error('No connected devices found')
        run_command(command='adb devices -l', print_output=True)
        sys.exit()

    devices_string = ''.join(devices)
    # fix adb no permissions issue
    if devices_string.find('no permissions') >= 0:
        log.warn('adb does not have permissions to communicate with device')
        run_command(command='adb devices -l | grep -w device', print_output=True)
        log.warn('Restarting adb')
        mpt.run_adb()
        devices = run_command(command='adb devices -l | grep -w device')

    if len(devices) > 1:
        log.error('Currently only single attached device is supported. Number of connected devices: {}'.format(dev_number))
        print_device_table()
        sys.exit()

    print_device_table()



def run_command(command, shell=True, return_output=True, print_output=False, universal_newlines=True,
                returncode=False):
    output = error = []
    try:
        log.debug('Executing command: {}'.format(command))

        process = subprocess.Popen(command, shell=shell, stdout=subprocess.PIPE,
                                   universal_newlines=universal_newlines)

        while True:
            nextline = process.stdout.readline()
            if nextline == '' and process.poll() is not None:
                break
            if print_output:
                sys.stdout.write(nextline)
            output.append(nextline)
            sys.stdout.flush()

        if returncode:
            return process.returncode

        if output and return_output:
            return output

    except Exception as e:
        log.exception(str(e))
        if error:
            log.error(error)
        sys.exit(1)


def run_interactive_command(command):
    log.debug('Executing inaractive command: {}'.format(command))

    cmd = command.split()
    code = os.spawnvpe(os.P_WAIT, cmd[0], cmd, os.environ)
    if code == 127:
        log.error('{0}: command not found'.format(cmd[0]))



def app_installed(app_name):
    app_found = run_command(
        command="""adb shell 'pm list packages -f' | sed -e 's/.*=//' | sort | grep {}""".format(app_name))
    if not app_found:
        log.error('Application \"{}\" is not installed on the device'.format(app_name))
        sys.exit()


def run_as(user):
    if user == 'user':
        if os.getuid() == 0:
            log.error('Run {} as user'.format(__name__))
            sys.exit(1)
    if user == 'root':
        if os.getuid() != 0:
            log.error('Run {} as root'.format(__name__))
            sys.exit(1)




def load_settings(setting_name):
    """
    mpt-setting file contains the following properties:

        pentest-dir: <working directory>
        app:
        package-name:
        proxy-host:
        proxy-port:

    :param setting_name:
    :return:
    """

    properties = ('pentest-dir', 'app', 'package-name', 'proxy-host', 'proxy-port')

    cfg_path = os.path.join(settings.HOME_FOLDER, settings.CONFIG)

    if not os.path.isfile(cfg_path):
        log.error('Configuration file {} does not exist. Please run --setup' .format(cfg_path))
        sys.exit()
    else:

        if setting_name not in properties:
            log.error('Wrong property {} (file: {})'.format(setting_name, cfg_path))
            sys.exit()

        # combine to python dict
        config_file = [line.rstrip('\n') for line in open(cfg_path)]
        config = {x.split(':')[0].strip(): x.split(':')[1].strip() for x in config_file}

        if setting_name not in config.keys():
            log.error('{} value is not set (file: {})'.format(setting_name, cfg_path))
            log.error('{} value is not set (file: {})'.format(setting_name, cfg_path))
            sys.exit()

        return config[setting_name]



def install_git(package):

    # supports only git clone
    if settings.ANDROID_TOOLS[package]['install'] == 'git':
        git_repo = settings.ANDROID_TOOLS[package]['url']
        log.info('Cloning repo: {}'.format(git_repo))
        clone_path = os.path.join(settings.MOBILE_FOLDER, package)
        if os.path.exists(clone_path):
            log.warn('Folder {} already exists. Skip installation.'.format(clone_path))
        else:
            Repo.clone_from(url=git_repo, to_path=clone_path)


# http downaload
def install_http(package):

    # supports only download via http
    if settings.ANDROID_TOOLS[package]['install'] == 'http':
        bin_path = settings.ANDROID_TOOLS[package]['bin']
        if not os.path.exists(bin_path):
            tool_url = settings.ANDROID_TOOLS[package]['url']
            log.info('Downloading {} from {} '.format(package, tool_url))
            run_command(command='wget {} -O {} -q'.format(tool_url, bin_path), print_output=True)
        else:
            log.warn('Binary {} already exists. Skip installation.'.format(bin_path))

# download and unzip files
def install_zip(package):

    # supports only download via http
    if settings.ANDROID_TOOLS[package]['install'] == 'zip':

        tool_path = settings.ANDROID_TOOLS[package]['bin']
        tool_url = settings.ANDROID_TOOLS[package]['url']

        tool_dir = os.path.dirname(tool_path)
        if not os.path.exists( tool_dir ):
            temp_archive_filename = 'donwload-tmp.zip'
            run_command(command='cd {0}; wget -q {1} -O {2}; unzip -q {2}; rm {2}'
                        .format(settings.MOBILE_FOLDER, tool_url, temp_archive_filename, ), print_output=True)

            # execute post instructions
            if len(settings.ANDROID_TOOLS[package]['post']) > 0:
                run_command(command='cd {0}; '.format(settings.MOBILE_FOLDER) + settings.ANDROID_TOOLS[package]['post'])
        else:
            log.warn('Folder {} already exists. Skip installation.'.format(tool_dir) )


def install_app(app):

    log.info('Installing {0} app'.format(Fore.CYAN + app + Style.RESET_ALL))

    pkg = settings.ANDROID_APKS[app]['pkg']
    apk_file = os.path.join(settings.MPT_PATH,settings.ANDROID_APKS[app]['apk'])

    if not os.path.isfile(apk_file):
        log.error('File {} not found. Installation canceled.'.format(apk_file))
        sys.exit()

    app_found = run_command(
        command="""adb shell 'pm list packages -f' | grep {}""".format(pkg))

    if not app_found:
        run_command(
            command="adb install {}".format(apk_file))
    else:
        log.warn('Package {} already installed. Skip installation.'.format(pkg))


def install_packages(install):

    if install == 'tools':
        for package in settings.ANDROID_TOOLS:
            log.info('Installing {0} into directory: {1}'.format(Fore.CYAN + package + Style.RESET_ALL, settings.MOBILE_FOLDER))
            if settings.ANDROID_TOOLS[package]['install'] == 'git':
                install_git(package)
            if settings.ANDROID_TOOLS[package]['install'] == 'http':
                install_http(package)
            if settings.ANDROID_TOOLS[package]['install'] == 'zip':
                install_zip(package)

    elif install == 'apps':
        for app in settings.ANDROID_APKS:
            install_app(app)

    else:
        log.error('Only options \'tools\' and \'apps\' are supported')


def check_frida_is_running():
    frida_running = run_command(command='adb shell "ps" | grep {}'.format(settings.FRIDA_BIN), return_output=True)

    if not frida_running:
        log.error('Frida server is not running. Please start server before running the script (-f option)')
        sys.exit()

    # TODO replace ps with ps -A for Android 8.0
    # sometimes the app crashes and a new frida-helper starts.
    # If multiple helpers are running at the same time, frida does not work properly.
    pids = run_command(command='adb shell "ps" | grep frida-helper', return_output=True)
    if pids and len(pids) > 1:
        log.warn("Multiple frida-helper processes running, restarting frida")
        mpt.run_frida()



def kill_process_by_name(process_name):

    # TODO replace ps with ps -A for Android 8.0
    pids = run_command(command='adb shell "ps" | grep {}'.format(process_name), return_output=True)

    if pids:
        for pid in pids:
            pid = pid.split()[1]
            log.debug('Killing process {} [pid:{}]'.format(process_name, pid))
            # adb shell running as root (virtual device)
            id = get_shell_user_id()
            if id.find('uid=0(root)') >= 0:
                run_command(command="adb shell \"kill -9 {}\"".format(pid))
            # adb shell running as user (physical device)
            else:
                run_command(command="adb shell \"su -c kill -9 {}\"".format(pid))



def get_shell_user_id():

    id = run_command(command="adb shell id")
    id = ''.join(id).strip('\n').split(' ')[0]
    return id



def download_frida(arch):
    # download frida-server binary
    if not os.path.exists(settings.FRIDA_BIN):

        # get download link
        down_link = run_command(command='curl -s  https://api.github.com/repos/frida/frida/releases/latest |'
                                        ' grep browser | grep server | grep android ')
        if not down_link:
            log.error('Download frida from github failed')
            sys.exit()

        down_link = [x.split(':', 1) for x in down_link]
        # get second item and delete newline, quotes and trailing spaces
        down_link = [x[1].replace('\n', '').replace('"', '').strip() for x in down_link]
        for link in down_link:
            if '{}.'.format(arch) in link:
                down_link = link
                break

        # download file
        filename = os.path.basename(urlparse(down_link).path)
        log.info('Downloading frida {}'.format(down_link))
        run_command(command='wget -q {} -O {}'.format(down_link, filename), print_output=True)
        run_command(command='unxz {}'.format(filename), print_output=True)
        filename = os.path.splitext(filename)[0]
        log.info('Frida filename: {}'.format(filename))
        if os.path.isfile(filename):
            run_command(command='mv {} {}'.format(filename, settings.FRIDA_BIN))
            if os.path.isfile('{}.xz'.format(filename)):
                os.remove('{}.xz'.format(filename))
        else:
            log.error('{} file not found'.format(filename))
    else:
        log.info('File {} [{}] exists, skip downloading'.format(settings.FRIDA_BIN, arch))


def get_device_architecture():
    """
    :return: ['arm64', 'arm', 'x86_64', 'x86'] or exit
    """
    arch = run_command(command="adb shell getprop | grep -w 'cpu.abi'")
    arch = arch[0].split(' ')[1].strip('\n')
    arch = arch.replace('[', '').replace(']', '')
    log.info("Detected device architecture {}".format(Style.BRIGHT + arch + Style.RESET_ALL))

    # check architecture for physical devices
    available_arch = ['arm64', 'arm', 'x86_64', 'x86']
    if arch not in available_arch:

        if arch.find('arm64') >= 0:
            arch = 'arm64'
            log.warn('Architecture changed to {}'.format(arch))
        else:
            if arch.find('arm') >= 0:
                arch = 'arch'
                log.warn('Architecture changed to {}'.format(arch))

        if not arch:
            log.error('Frida server for architecture {} not found. Download frida manually'.format(arch))
            sys.exit()
        else:
            return arch